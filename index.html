<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Qureo Auto Solver - Ø§Ù„Ù…Ø·ÙˆØ±</title>
    <style>
        :root {
            --bg-color: #0f172a;
            --card-bg: #1e293b;
            --primary: #3b82f6;
            --success: #10b981;
            --error: #ef4444;
            --text: #f8fafc;
            --text-muted: #94a3b8;
            --warning: #f59e0b;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text);
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        .container {
            background-color: var(--card-bg);
            padding: 2rem;
            border-radius: 16px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            width: 100%;
            max-width: 600px;
            text-align: center;
        }

        h1 {
            margin-bottom: 1.5rem;
            color: var(--primary);
            font-size: 1.8rem;
        }

        h3 {
            color: var(--warning);
            margin: 1rem 0;
            text-align: right;
        }

        .input-group {
            margin-bottom: 1rem;
            text-align: right;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        input, select {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #334155;
            background-color: #0f172a;
            color: white;
            font-size: 1rem;
            box-sizing: border-box;
            outline: none;
            transition: 0.3s;
        }

        input:focus, select:focus {
            border-color: var(--primary);
        }

        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: 0.3s;
            margin-top: 1rem;
        }

        .btn-primary {
            background-color: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background-color: #2563eb;
        }

        .btn-secondary {
            background-color: #4b5563;
            color: white;
        }

        .btn-secondary:hover {
            background-color: #374151;
        }

        .btn-stop {
            background-color: var(--error);
            color: white;
            display: none;
        }

        .btn-stop:hover {
            background-color: #dc2626;
        }

        .logs {
            margin-top: 2rem;
            background-color: #0f172a;
            border-radius: 8px;
            padding: 1rem;
            height: 200px;
            overflow-y: auto;
            text-align: right;
            font-family: monospace;
            font-size: 0.85rem;
            border: 1px solid #334155;
        }

        .log-entry {
            margin-bottom: 5px;
            padding-bottom: 5px;
            border-bottom: 1px solid #1e293b;
        }
        .log-success { color: var(--success); }
        .log-error { color: var(--error); }
        .log-info { color: var(--text-muted); }
        .log-warn { color: var(--warning); }
        .log-proxy { color: #8b5cf6; }

        /* Tabs */
        .tabs {
            display: flex;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid #334155;
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            color: var(--text-muted);
            border-bottom: 2px solid transparent;
            transition: 0.3s;
        }

        .tab.active {
            color: var(--primary);
            border-bottom: 2px solid var(--primary);
        }

        .tab-content {
            display: none;
            text-align: right;
        }

        .tab-content.active {
            display: block;
        }

        .proxy-status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 8px;
            background-color: rgba(59, 130, 246, 0.1);
            border: 1px solid var(--primary);
        }

        .proxy-status.error {
            background-color: rgba(239, 68, 68, 0.1);
            border-color: var(--error);
        }

        .proxy-status.success {
            background-color: rgba(16, 185, 129, 0.1);
            border-color: var(--success);
        }

        .proxy-list {
            max-height: 150px;
            overflow-y: auto;
            margin: 10px 0;
            padding: 10px;
            background-color: #0f172a;
            border-radius: 8px;
        }

        .proxy-item {
            padding: 5px;
            margin: 3px 0;
            background-color: #1e293b;
            border-radius: 4px;
            cursor: pointer;
            transition: 0.3s;
        }

        .proxy-item:hover {
            background-color: #334155;
        }

        .proxy-item.active {
            background-color: var(--primary);
        }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 4px; }

        .hidden { display: none; }
    </style>
</head>
<body>

    <div class="container">
        <h1>ğŸ¤– Qureo Solver Web</h1>
        
        <div class="tabs">
            <div class="tab active" onclick="switchTab('login')">ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„</div>
            <div class="tab" onclick="switchTab('proxy')">Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¨Ø±ÙˆÙƒØ³ÙŠ</div>
            <div class="tab" onclick="switchTab('info')">Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª</div>
        </div>

        <div id="loginTab" class="tab-content active">
            <div class="input-group">
                <label>Ø±Ù‚Ù… Ø§Ù„Ø·Ø§Ù„Ø¨ (Student ID)</label>
                <input type="text" id="studentId" placeholder="Ø£Ø¯Ø®Ù„ Ø§Ù„Ø±Ù‚Ù… Ù‡Ù†Ø§">
            </div>
            <div class="input-group">
                <label>ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± (Password)</label>
                <input type="password" id="password" placeholder="Ø£Ø¯Ø®Ù„ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±">
            </div>
            <div class="input-group">
                <label>Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø§ØªØµØ§Ù„</label>
                <select id="connectionMethod">
                    <option value="direct">Ø§ØªØµØ§Ù„ Ù…Ø¨Ø§Ø´Ø± (Ù…Ø¹ Ø¥Ø¶Ø§ÙØ© CORS)</option>
                    <option value="proxy">Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¨Ø±ÙˆÙƒØ³ÙŠ ØªÙ„Ù‚Ø§Ø¦ÙŠ</option>
                </select>
            </div>
            <button class="btn btn-primary" onclick="startProcess()">ğŸš€ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ ÙˆØ¨Ø¯Ø¡ Ø§Ù„Ø­Ù„</button>
        </div>

        <div id="proxyTab" class="tab-content">
            <h3>ğŸ“¡ Ù†Ø¸Ø§Ù… Ø§Ù„Ø¨Ø±ÙˆÙƒØ³ÙŠ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ</h3>
            <div class="input-group">
                <label>Ù‚Ø§Ø¦Ù…Ø© Ø¨Ø±ÙˆÙƒØ³ÙŠØ§Øª Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)</label>
                <textarea id="customProxies" placeholder="https://corsproxy.io/?https://me-portal.qureo.education
https://api.allorigins.win/raw?url=https://me-portal.qureo.education" rows="4"></textarea>
            </div>
            
            <div id="proxyStatus" class="proxy-status">
                â³ Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø¨Ø±ÙˆÙƒØ³ÙŠ Ø§Ù„Ù…ØªÙˆÙØ±...
            </div>
            
            <button class="btn btn-secondary" onclick="testProxies()">ğŸ”„ Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø¨Ø±ÙˆÙƒØ³ÙŠØ§Øª</button>
            <button class="btn btn-primary" onclick="findWorkingProxy()">ğŸ” Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¨Ø±ÙˆÙƒØ³ÙŠ ØªÙ„Ù‚Ø§Ø¦ÙŠ</button>
        </div>

        <div id="infoTab" class="tab-content">
            <h3>â„¹ï¸ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø­ÙˆÙ„ Ø§Ù„Ù†Ø¸Ø§Ù…</h3>
            <div style="text-align: right; line-height: 1.6;">
                <p>âœ… Ù‡Ø°Ø§ Ø§Ù„Ù†Ø¸Ø§Ù… ÙŠØ³ØªØ®Ø¯Ù… Ø¨Ø±ÙˆÙƒØ³ÙŠØ§Øª CORS Ù„Ù„Ø§ØªØµØ§Ù„ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±</p>
                <p>ğŸ”’ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØªÙØ¹Ø§Ù„Ø¬ Ù…Ø­Ù„ÙŠØ§Ù‹ ÙÙŠ Ù…ØªØµÙØ­Ùƒ</p>
                <p>âš¡ Ø§Ù„Ø¨Ø±ÙˆÙƒØ³ÙŠØ§Øª Ø§Ù„Ù…Ø¶Ù…Ù†Ø©:</p>
                <ul style="text-align: right; padding-right: 1rem;">
                    <li>corsproxy.io</li>
                    <li>api.allorigins.win</li>
                    <li>cors-anywhere.herokuapp.com</li>
                    <li>proxy.cors.sh</li>
                </ul>
                <p class="log-warn">âš ï¸ Ù‚Ø¯ ÙŠØ®ØªÙ„Ù Ø³Ø±Ø¹Ø© Ø§Ù„Ø¹Ù…Ù„ Ø­Ø³Ø¨ Ø§Ù„Ø¨Ø±ÙˆÙƒØ³ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…</p>
            </div>
        </div>

        <div id="controlPanel" class="hidden">
            <div class="status-box">
                <p id="statusText">Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¹Ù…Ù„...</p>
                <p id="currentProxyInfo" class="log-proxy"></p>
            </div>
            <button class="btn btn-stop" id="stopBtn" onclick="stopProcess()">ğŸ›‘ Ø¥ÙŠÙ‚Ø§Ù</button>
        </div>

        <div class="logs" id="logsContainer">
            <div class="log-entry log-info">Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª...</div>
        </div>
    </div>

    <script>
        // ================= Configuration =================
        const BASE_URL = "https://me-tp.qureo.education";
        const PORTAL_URL = "https://me-portal.qureo.education";
        let isRunning = false;
        let currentProxy = null;
        
        // ================= Proxy System =================
        const BUILTIN_PROXIES = [
            "https://corsproxy.io/?",
            "https://api.allorigins.win/raw?url=",
            "https://cors-anywhere.herokuapp.com/",
            "https://proxy.cors.sh/",
            "https://api.codetabs.com/v1/proxy?quest=",
            "https://cors-proxy.htmldriven.com/?url=",
            "https://crossorigin.me/",
            "https://thingproxy.freeboard.io/fetch/"
        ];
        
        // ================= Tab System =================
        function switchTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(tabName + 'Tab').classList.add('active');
            event.target.classList.add('active');
        }
        
        // ================= Logger =================
        function log(msg, type = 'info') {
            const container = document.getElementById('logsContainer');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            const time = new Date().toLocaleTimeString('en-US', {hour12: false});
            entry.innerText = `[${time}] ${msg}`;
            container.prepend(entry);
        }
        
        // ================= Proxy Management =================
        async function findWorkingProxy() {
            const proxyStatus = document.getElementById('proxyStatus');
            proxyStatus.className = 'proxy-status';
            proxyStatus.innerHTML = 'ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¨Ø±ÙˆÙƒØ³ÙŠ ÙØ¹Ø§Ù„...';
            
            // Get all proxies (built-in + custom)
            let allProxies = [...BUILTIN_PROXIES];
            const customText = document.getElementById('customProxies').value;
            if (customText) {
                const customProxies = customText.split('\n').map(p => p.trim()).filter(p => p);
                allProxies = [...customProxies, ...allProxies];
            }
            
            log(`ğŸ” Ø¬Ø§Ø±ÙŠ Ø§Ø®ØªØ¨Ø§Ø± ${allProxies.length} Ø¨Ø±ÙˆÙƒØ³ÙŠ...`, 'proxy');
            
            for (const proxy of allProxies) {
                if (!isRunning) break;
                
                const testUrl = proxy + encodeURIComponent(PORTAL_URL);
                try {
                    const test = await fetch(testUrl, {
                        method: 'HEAD',
                        timeout: 5000
                    }).catch(() => null);
                    
                    if (test && test.ok) {
                        currentProxy = proxy;
                        proxyStatus.className = 'proxy-status success';
                        proxyStatus.innerHTML = `âœ… ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨Ø±ÙˆÙƒØ³ÙŠ ÙØ¹Ø§Ù„: ${proxy.split('/')[2]}`;
                        log(`âœ… Ø¨Ø±ÙˆÙƒØ³ÙŠ ÙØ¹Ø§Ù„: ${proxy}`, 'success');
                        
                        // Update status display
                        const proxyInfo = proxy.split('/')[2];
                        document.getElementById('currentProxyInfo').textContent = `ğŸ”— Ø§Ù„Ø¨Ø±ÙˆÙƒØ³ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: ${proxyInfo}`;
                        
                        return proxy;
                    }
                } catch (e) {
                    // Continue to next proxy
                }
            }
            
            proxyStatus.className = 'proxy-status error';
            proxyStatus.innerHTML = 'âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨Ø±ÙˆÙƒØ³ÙŠ ÙØ¹Ø§Ù„. Ø­Ø§ÙˆÙ„ Ø¥Ø¶Ø§ÙØ© Ø¨Ø±ÙˆÙƒØ³ÙŠØ§Øª ÙŠØ¯ÙˆÙŠØ§Ù‹.';
            log('âŒ ÙØ´Ù„ Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨Ø±ÙˆÙƒØ³ÙŠ ÙØ¹Ø§Ù„', 'error');
            return null;
        }
        
        async function testProxies() {
            const proxyStatus = document.getElementById('proxyStatus');
            proxyStatus.className = 'proxy-status';
            proxyStatus.innerHTML = 'âš¡ Ø¬Ø§Ø±ÙŠ Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø¨Ø±ÙˆÙƒØ³ÙŠØ§Øª...';
            
            const proxyList = document.createElement('div');
            proxyList.className = 'proxy-list';
            
            const allProxies = [...BUILTIN_PROXIES];
            const customText = document.getElementById('customProxies').value;
            if (customText) {
                const customProxies = customText.split('\n').map(p => p.trim()).filter(p => p);
                allProxies.unshift(...customProxies);
            }
            
            for (const proxy of allProxies) {
                const proxyItem = document.createElement('div');
                proxyItem.className = 'proxy-item';
                proxyItem.textContent = `â³ Ø§Ø®ØªØ¨Ø§Ø±: ${proxy.split('/')[2] || proxy}`;
                proxyList.appendChild(proxyItem);
                
                try {
                    const test = await fetch(proxy + encodeURIComponent(PORTAL_URL), {
                        method: 'HEAD'
                    }).catch(() => null);
                    
                    if (test && test.ok) {
                        proxyItem.innerHTML = `âœ… ${proxy.split('/')[2] || proxy}`;
                        proxyItem.style.color = '#10b981';
                    } else {
                        proxyItem.innerHTML = `âŒ ${proxy.split('/')[2] || proxy}`;
                        proxyItem.style.color = '#ef4444';
                    }
                } catch (e) {
                    proxyItem.innerHTML = `âŒ ${proxy.split('/')[2] || proxy}`;
                    proxyItem.style.color = '#ef4444';
                }
            }
            
            proxyStatus.innerHTML = '';
            proxyStatus.appendChild(document.createTextNode('Ù†ØªÙŠØ¬Ø© Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø¨Ø±ÙˆÙƒØ³ÙŠØ§Øª:'));
            proxyStatus.appendChild(proxyList);
        }
        
        // ================= Enhanced Fetch with Proxy =================
        async function smartFetch(url, options = {}) {
            const connectionMethod = document.getElementById('connectionMethod').value;
            
            // Direct connection (requires CORS extension)
            if (connectionMethod === 'direct' || currentProxy === null) {
                try {
                    const response = await fetch(url, options);
                    return response;
                } catch (error) {
                    log(`âŒ ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±: ${error.message}`, 'error');
                    
                    // Try to find proxy automatically
                    if (!currentProxy) {
                        await findWorkingProxy();
                    }
                    
                    if (currentProxy) {
                        return await proxyFetch(url, options);
                    }
                    
                    throw error;
                }
            }
            
            // Use proxy
            return await proxyFetch(url, options);
        }
        
        async function proxyFetch(url, options = {}) {
            if (!currentProxy) {
                const found = await findWorkingProxy();
                if (!found) {
                    throw new Error('Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø¨Ø±ÙˆÙƒØ³ÙŠ ÙØ¹Ø§Ù„');
                }
            }
            
            const proxyUrl = currentProxy + encodeURIComponent(url);
            
            // Clone options to avoid mutation
            const proxyOptions = { ...options };
            
            // Remove Content-Type for GET/HEAD requests if proxied
            if (proxyOptions.method && ['GET', 'HEAD'].includes(proxyOptions.method.toUpperCase())) {
                delete proxyOptions.headers['Content-Type'];
            }
            
            try {
                const response = await fetch(proxyUrl, proxyOptions);
                return response;
            } catch (error) {
                log(`âŒ ÙØ´Ù„ Ø§Ù„Ø¨Ø±ÙˆÙƒØ³ÙŠ Ø§Ù„Ø­Ø§Ù„ÙŠ: ${currentProxy}`, 'error');
                
                // Try to find new proxy
                const newProxy = await findWorkingProxy();
                if (newProxy) {
                    return await proxyFetch(url, options);
                }
                
                throw error;
            }
        }
        
        // ================= Utilities =================
        const sleep = (ms) => new Promise(r => setTimeout(r, ms));
        
        function getHeaders() {
            return {
                "Content-Type": "application/json",
                "Accept": "*/*"
            };
        }
        
        // ================= Core Logic =================
        async function startProcess() {
            const studentId = document.getElementById('studentId').value;
            const password = document.getElementById('password').value;
            
            if (!studentId || !password) {
                log("ÙŠØ±Ø¬Ù‰ Ù…Ù„Ø¡ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø­Ù‚ÙˆÙ„", "error");
                return;
            }
            
            isRunning = true;
            document.getElementById('loginForm')?.classList.add('hidden');
            document.getElementById('controlPanel').classList.remove('hidden');
            document.getElementById('stopBtn').style.display = 'block';
            document.getElementById('statusText').textContent = 'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¹Ù…Ù„...';
            
            // Initialize proxy if needed
            const connectionMethod = document.getElementById('connectionMethod').value;
            if (connectionMethod === 'proxy' && !currentProxy) {
                log("ğŸ” Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¨Ø±ÙˆÙƒØ³ÙŠ ÙØ¹Ø§Ù„...", "proxy");
                const proxy = await findWorkingProxy();
                if (!proxy) {
                    log("âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨Ø±ÙˆÙƒØ³ÙŠ ÙØ¹Ø§Ù„. Ø§Ù„Ø±Ø¬Ø§Ø¡ ØªÙØ¹ÙŠÙ„ Ø¥Ø¶Ø§ÙØ© CORS.", "error");
                    stopProcess();
                    return;
                }
            }
            
            try {
                const loggedIn = await login(studentId, password);
                if (loggedIn) {
                    log("ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ù†Ø¬Ø§Ø­!", "success");
                    await runSolverLoop();
                } else {
                    log("ÙØ´Ù„ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„. ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø£Ùˆ Ø¬Ø±Ø¨ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¨Ø±ÙˆÙƒØ³ÙŠ.", "error");
                    stopProcess();
                }
            } catch (e) {
                log(`Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹: ${e.message}`, "error");
                stopProcess();
            }
        }
        
        function stopProcess() {
            isRunning = false;
            document.getElementById('loginTab').classList.remove('hidden');
            document.getElementById('controlPanel').classList.add('hidden');
            log("ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¹Ù…Ù„ÙŠØ©.", "warn");
        }
        
        async function login(studentId, password) {
            log("Ø¬Ø§Ø±ÙŠ Ù…Ø­Ø§ÙˆÙ„Ø© ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„...", "info");
            try {
                const url = `${PORTAL_URL}/oauth2/password-login`;
                const response = await smartFetch(url, {
                    method: 'POST',
                    headers: getHeaders(),
                    body: JSON.stringify({ student_id: studentId, password: password })
                });
                
                if (response.ok) return true;
                
                // Try with specific error handling
                const errorText = await response.text();
                log(`âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„: ${response.status}`, "error");
                return false;
            } catch (e) {
                console.error(e);
                return false;
            }
        }
        
        async function runSolverLoop() {
            while (isRunning) {
                log("ğŸ” Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø¯Ø±Ø³ Ø§Ù„ØªØ§Ù„ÙŠ...", "info");
                
                const lectureId = await findActiveLecture(5);
                
                if (lectureId === "DONE") {
                    log("ğŸ‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¯Ø±ÙˆØ³ ÙÙŠ Ù‡Ø°Ø§ Ø§Ù„Ù‚Ø³Ù… Ù…ÙƒØªÙ…Ù„Ø©!", "success");
                    stopProcess();
                    break;
                }
                
                if (!lectureId) {
                    log("âš ï¸ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¯Ø±ÙˆØ³ Ø£Ùˆ Ø­Ø¯Ø« Ø®Ø·Ø£. Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©...", "warn");
                    await sleep(3000);
                    continue;
                }
                
                log(`ğŸ“ Ø¨Ø¯Ø¡ Ø­Ù„ Ø§Ù„Ø¯Ø±Ø³: ${lectureId}`, "info");
                const success = await solveLectureSteps(lectureId);
                
                if (success) {
                    log(`âœ… ØªÙ… Ø¥Ù†Ù‡Ø§Ø¡ Ø§Ù„Ø¯Ø±Ø³ ${lectureId} Ø¨Ù†Ø¬Ø§Ø­!`, "success");
                    await sleep(2000);
                } else {
                    log(`âŒ ÙØ´Ù„ ÙÙŠ Ø­Ù„ Ø§Ù„Ø¯Ø±Ø³ ${lectureId}`, "error");
                    await sleep(5000);
                }
            }
        }
        
        async function findActiveLecture(sectionId) {
            try {
                const chapRes = await smartFetch(`${BASE_URL}/api/study/students/sections/${sectionId}/chapters`);
                if (!chapRes.ok) return null;
                const chapters = await chapRes.json();
                
                for (const chapter of chapters) {
                    if (!isRunning) return null;
                    if (chapter.completed_at) continue;
                    
                    const lecRes = await smartFetch(`${BASE_URL}/api/study/students/chapters/${chapter.chapter_id}/lectures`);
                    if (!lecRes.ok) continue;
                    const lectures = await lecRes.json();
                    
                    for (const lecture of lectures) {
                        if (!isRunning) return null;
                        if (lecture.completed_at || lecture.status === 'completed') continue;
                        return lecture.id || lecture.lecture_id;
                    }
                }
                return "DONE";
            } catch (e) {
                console.error(e);
                return null;
            }
        }
        
        async function solveLectureSteps(lectureId) {
            try {
                const sourceRes = await smartFetch(`${BASE_URL}/api/study/lectures/${lectureId}`);
                if (!sourceRes.ok) return false;
                const sourceData = await sourceRes.json();
                
                const answersMap = {};
                const steps = sourceData.talks || sourceData.steps || [];
                
                steps.forEach(step => {
                    const sId = step.id;
                    const body = step.body || {};
                    const type = step.type;
                    
                    if (type === 'programming' && body.codes && body.codes.length > 0) {
                        if (body.codes[0].model_answer) {
                            answersMap[sId] = { type: 'code', val: body.codes[0].model_answer };
                        }
                    } else if (type === 'choice' && body.options) {
                        body.options.forEach((opt, idx) => {
                            if (opt.is_correct) {
                                answersMap[sId] = { type: 'choice', val: (idx + 1).toString() };
                            }
                        });
                    }
                });
                
                const studentRes = await smartFetch(`${BASE_URL}/api/study/students/lectures/${lectureId}`);
                if (!studentRes.ok) return false;
                const studentData = await studentRes.json();
                const studentTalks = studentData.talks || studentData.steps || [];
                
                for (const talk of studentTalks) {
                    if (!isRunning) return false;
                    
                    const talkId = talk.talk_id || talk.id;
                    
                    if (answersMap[talkId]) {
                        await submitStep(talkId, answersMap[talkId].val, answersMap[talkId].type);
                        log(`â¡ï¸ Ø­Ù„ Ø®Ø·ÙˆØ© (ID: ${talkId}) Ù†ÙˆØ¹: ${answersMap[talkId].type}`, "info");
                    } else {
                        await submitStep(talkId, null, "pass");
                    }
                    
                    await sleep(800);
                }
                
                await smartFetch(`${BASE_URL}/api/study/students/lectures/${lectureId}/complete`, {
                    method: 'PUT',
                    headers: getHeaders(),
                    body: JSON.stringify({})
                });
                
                return true;
                
            } catch (e) {
                console.error(e);
                return false;
            }
        }
        
        async function submitStep(talkId, answer, type) {
            const url = `${BASE_URL}/api/study/students/lecture-talks/${talkId}`;
            let payload = {};
            
            if (type === "code") {
                payload = {
                    "value": {"try_demo": {"lang": "javascript", "answer": answer}},
                    "status": "completed"
                };
            } else if (type === "choice") {
                payload = {
                    "value": {"choice_question": {"value": answer}},
                    "status": "completed"
                };
            } else {
                payload = {
                    "value": {},
                    "status": "completed"
                };
            }
            
            try {
                await smartFetch(url, {
                    method: 'PUT',
                    headers: getHeaders(),
                    body: JSON.stringify(payload)
                });
            } catch (e) {
                log(`âš ï¸ Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø®Ø·ÙˆØ©: ${e.message}`, 'warn');
            }
        }
        
        // Initialize on load
        window.addEventListener('load', async () => {
            log("ğŸš€ Ø§Ù„Ù†Ø¸Ø§Ù… Ø¬Ø§Ù‡Ø² Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…", "success");
            log("ğŸ“Œ Ø­Ø¯Ø¯ Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø§ØªØµØ§Ù„ Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ù†Ø³Ø¯Ù„Ø©", "info");
            
            // Auto-test proxies in background
            setTimeout(async () => {
                if (!currentProxy) {
                    await findWorkingProxy();
                }
            }, 1000);
        });
        
    </script>
</body>
    </html>
